#!/usr/bin/python3 --
import sys
from binascii import a2b_base64, b2a_base64

class BadCommandError(ValueError):
    pass

prefix = b"-----BEGIN PGP SIGNED MESSAGE-----\nHash: "
sig_start = b"-----BEGIN PGP SIGNATURE-----\n"
sig_end = b"\n-----END PGP SIGNATURE-----\n"
shortest_sig = sig_start + b"""

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
=AAAA""" + sig_end
shortest_input = prefix + b"""SHA256

Build-template\x20a\n""" + shortest_sig

def check_base64(untrusted_bytes: bytes) -> None:
    for i in untrusted_bytes:
        if ((0x41 <= i <= 0x5A) or # A-Z
            (0x61 <= i <= 0x7A) or # a-z
            (0x30 <= i <= 0x39) or # 0-9
            (i == 0x2F) or # '/'
            (i == 0x2B)): # '+'
            pass
        else:
            raise BadCommandError('invalid base64 character')

def check_command(untrusted_command: bytes) -> None:
    if len(untrusted_command) > 255:
        raise BadCommandError('command too long')
    last_c = 0x20
    for i in untrusted_command:
        if ((0x41 <= i <= 0x5A) or # A-Z
            (0x61 <= i <= 0x7A) or # a-z
            (0x30 <= i <= 0x39) or # 0-9
            (i == 0x5F) or # '_'
            (i == 0x2E)): # '.'
            pass
        elif ((i == 0x2D) or # '-'
              (i == 0x20)): # ' '
            if last_c == 0x20:
                raise BadCommandError('Double spaces or space-dash in command')
        else:
            raise BadCommandError('invalid character in command')
        last_c = i
    if not (untrusted_command.startswith(b'Build-template ') or
            untrusted_command.startswith(b'Upload ')):
        raise BadCommandError('Unknown command')
    if untrusted_command[-1] <= 0x20:
        raise BadCommandError('Trailing whitespace in command forbidden')

def check_one_signature_packet(untrusted_binary_sig: bytes, hash_str: bytes) -> None:
    """
    Check that a byte string is exactly one OpenPGP signature packet.
    The contents of the packet are not checked.
    """
    sig_len = len(untrusted_binary_sig)
    if sig_len < 64:
        raise BadCommandError('signature too short to be valid')
    untrusted_first_byte = untrusted_binary_sig[0]
    if not (untrusted_first_byte & 0x80):
        raise BadCommandError('first bit zero')
    packet_length = 0
    if untrusted_first_byte & 0x40:
        # new-format packet
        tag = untrusted_first_byte & 0x3F
        untrusted_first_byte = untrusted_binary_sig[1]
        if untrusted_first_byte < 192:
            packet_length = untrusted_first_byte
            len_bytes = 1
        elif untrusted_first_byte < 224:
            packet_length = (((untrusted_first_byte - 192) << 8) +
                             untrusted_binary_sig[1] + 192)
            len_bytes = 2
        elif untrusted_first_byte == 255:
            packet_length = 0
            len_bytes = 5
            for i in untrusted_binary_sig[2:6]:
                packet_length = packet_length << 8 | i
        else:
            raise BadCommandError('unsupported partial-length packet')
    else:
        # old-format packet
        len_bytes = 1 << (untrusted_first_byte & 0x3)
        tag = (untrusted_first_byte >> 2) & 0xF
        if len_bytes > 4:
            raise BadCommandError('forbidden indefinite-length packet')
        for i in untrusted_binary_sig[1:len_bytes + 1]:
            packet_length = packet_length << 8 | i
    if packet_length != sig_len - len_bytes - 1:
        raise BadCommandError('bad signature length')
    if tag != 2:
        raise BadCommandError('packet is not a signature')
    if untrusted_binary_sig[len_bytes + 1] != 4:
        raise BadCommandError('only version 4 signatures allowed')
    if untrusted_binary_sig[len_bytes + 2] != 1:
        raise BadCommandError('expected signature of type 1, got something else')
    hash_alg = untrusted_binary_sig[len_bytes + 4]
    if hash_alg < 8 or hash_alg > 10:
        raise BadCommandError('unsupported hash algorithm')
    if hash_str != (b'SHA256', b'SHA384', b'SHA512')[hash_alg - 8]:
        raise BadCommandError('hash algorithm mismatch')

def reconstruct_armored_sig(untrusted_binary_crc24: bytes, untrusted_binary_sig: bytes) -> bytes:
    """
    Reconstruct an armored signature from the components
    """
    untrusted_array = [sig_start]
    untrusted_encoded = b2a_base64(untrusted_binary_sig, newline=False)
    untrusted_array += (untrusted_encoded[i:i+64] for i in range(0, len(untrusted_encoded), 64))
    untrusted_array.append(b'=' + b2a_base64(untrusted_binary_crc24, newline=False) + sig_end)
    return b'\n'.join(untrusted_array)

def canonicalize_sig(untrusted_armored_sig: bytes, hash_str: bytes) -> bytes:
    """
    Canonicalize an ASCII-armored cleartext signature.

    hash_str is the value of the Hash: armor line.
    """
    # Check that the signature is long enough
    if len(untrusted_armored_sig) < len(shortest_sig):
        raise BadCommandError('sig too short')

    # Check the start and end of the signature
    if not untrusted_armored_sig.startswith(sig_start):
        raise BadCommandError('Invalid start of signature')
    if not untrusted_armored_sig.endswith(sig_end):
        raise BadCommandError('Invalid end of signature (trailing junk?)')

    # Check and extract the CRC
    if untrusted_armored_sig[-35:-33] != b'\n=':
        raise BadCommandError('Missing or misplaced CRC')
    untrusted_b64_crc24 = untrusted_armored_sig[-33:-29]
    check_base64(untrusted_b64_crc24)
    untrusted_crc24 = a2b_base64(untrusted_b64_crc24)
    del untrusted_b64_crc24

    # Parse the base64 data
    untrusted_base64_body = untrusted_armored_sig[len(sig_start):-35].replace(b'\n', b'')
    sig_base64_len = len(untrusted_base64_body)
    if sig_base64_len < 88:
        raise BadCommandError('sig too short')
    if sig_base64_len % 4:
        raise BadCommandError('base64-encoded data has length not a multiple of 4')
    if untrusted_base64_body[-1] == ord('='):
        if untrusted_base64_body[-2] == ord('='):
            check_base64(untrusted_base64_body[:-2])
            if untrusted_base64_body[-3] not in (65, 81, 103, 119):
                raise BadCommandError('bad base64 line: bad byte before padding')
        elif untrusted_base64_body[-2] not in {48, 52, 56, 65, 69, 73, 77, 81, 85, 89, 99, 103, 107, 111, 115, 119}:
            raise BadCommandError('bad base64 line: bad byte before padding')
        else:
            check_base64(untrusted_base64_body[:-1])
    else:
        check_base64(untrusted_base64_body)
    untrusted_sig_to_write = a2b_base64(untrusted_base64_body)

    # Check that the signature is a single packet of the correct type
    check_one_signature_packet(untrusted_sig_to_write, hash_str)

    # And reconstruct the armored signature.
    return reconstruct_armored_sig(untrusted_crc24, untrusted_sig_to_write)

def main(command_file, sig_file) -> None:
    untrusted_input = sys.stdin.buffer.read(8192)
    if sys.stdin.buffer.read(1):
        raise BadCommandError('Command too long (limit is 8192 bytes)')
    if len(untrusted_input) < len(shortest_input):
        raise BadCommandError('input too short')
    if not untrusted_input.startswith(prefix):
        raise BadCommandError('not an inline signed message')
    if not untrusted_input.endswith(b'\n'):
        raise BadCommandError('No trailing newline (webhook bug?)')
    if untrusted_input[41:49] not in (b'SHA256\n\n', b'SHA384\n\n', b'SHA512\n\n'):
        raise BadCommandError('bad hash algorithm')
    hash_str = untrusted_input[41:47]

    untrusted_command, untrusted_sig = untrusted_input[49:].split(b'\n', 1)
    check_command(untrusted_command)

    reconstructed_sig = canonicalize_sig(untrusted_sig, hash_str)
    with open(sig_file, 'wb') as s, open(command_file, 'wb') as c:
        s.write(reconstructed_sig)
        s.flush()
        c.write(untrusted_command)
        c.flush()

if __name__ == '__main__':
    try:
        main(sys.argv[1], sys.argv[2])
    except (BadCommandError, IOError) as e:
        print(e, file=sys.stderr)
        sys.exit(1)
